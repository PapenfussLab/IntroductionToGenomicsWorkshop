---
title: "Genomics Workshop: Task 3"
author: 
  - Ruining Dong^[dong.rn@wehi.edu.au]
  - James Fu^[fu.j@wehi.edu.au]
  - Daniel Cameron^[cameron.d@wehi.edu.au]
output: 
  rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Genomic Workshop Task 3}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```

### Task 3: investigating the driver gene

#### *Load packages*

```{r, eval = TRUE, message = FALSE}
library(VariantAnnotation)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(BSgenome.Hsapiens.UCSC.hg19)
```

#### *Read and pre-process VCF file*

We use the `VariantAnnotation` package to read and annotate the SNVs we just found.

```{r, eval = TRUE}
file_dir <- "/home/rstudio/colo829/full/strelka/COLO829R_COLO829T_strelka_passed.somatic.merged.vcf"
vcf <- readVcf(file_dir)
```

The VCF file is modified to maintain its consistency with other databases.

```{r, eval = TRUE}
seqlevels(vcf) <- paste0("chr", seqlevels(vcf))
vcf = renameSeqlevels(vcf, c(chrMT="chrM"))
seqlengths(vcf)["chrM"] <- 16571
```

#### *Header information of VCF file*

`header()` function will show the header information from the VCF file.

```{r, eval = TRUE}
header(vcf)
```

Further information for the headers can be extracted by functions like `samples(), geno(), meta()`, etc.

<details>
<summary>Solution</summary>
<ul>
<li>This will fail.</li>
```{r, eval = TRUE, error = TRUE}
samples(vcf)
```
<li>These will work.</li>
```{r, eval = TRUE}
samples(header(vcf))
```
<li>**Worth mentioning? Explanation?**</li>
```{r, eval = TRUE}
geno(vcf)
head(geno(header(vcf)), 3)
```
</ul>
</details>

#### *Variant genomic position*

The chromosomal location for each SNV can be identified by `rowRanges()`.

```{r, eval = TRUE}
head(rowRanges(vcf), 3)
```

Individual fields can be pulled out either with the `$` sign or named accessors like `ref(), alt()`.

```{r, eval = TRUE}
head(rowRanges(vcf)$ALT, 3)
head(alt(vcf), 3)
```

#### *Locate variants in and around genes*

Variant location with respect to genes can be identified with the `locateVariants()` function.

```{r, eval = TRUE, message = FALSE, warning = FALSE}
# Get variant location information.
rd <- rowRanges(vcf)
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
loc <- locateVariants(rd, txdb, CodingVariants())
head(loc, 3)
```

The number of SNVs on each chromosome can be displayed by `seqnames()`.

```{r, eval = TRUE, warning = FALSE}
seqnames(loc)
```

The documentation of `locateVariants()` describes how to identify variants in other regions, like *splicing sites*.

<details>
<summary>Solution</summary>
<ul>
<li>Check the documentation of `locateVariants()`.</li>
```{r, eval = TRUE}
?locateVariants
```
<li>
Following functions are used to identify variants in distinct gene regions:

| Function             | Description                                                           |
|----------------------|-----------------------------------------------------------------------|
| CodingVariants()     | Falls within a coding region                                          |
| IntronVariants()     | Falls within an intron region                                         |
| FiveUTRVariants()    | Falls within a 5' untranslated region                                 |
| ThreeUTRVariants()   | Falls within a 3' untranslated region                                 |
| IntergenicVariants() | Does not fall within a transcript associated with a gene              |
| SpliceSiteVariants() | Overlaps any portion of the first 2 or last 2 nucleotide of an intron |
| PromoterVariants()   | Falls within a promoter region of a transcript                        |
| AllVariants()        | All regions                                                           |
</li>
```{r, eval = TRUE, message = FALSE}
loc_splice <- locateVariants(rd, txdb, SpliceSiteVariants())
head(loc_splice, 3)
seqnames(loc_splice)
```
</ul>
</details>

#### *Amino acid coding changes*

`predictCoding` computes amino acid coding changes for non-synonymous mutations.

```{r, eval = TRUE, warning = FALSE}
coding <- predictCoding(vcf, txdb, seqSource = Hsapiens)
coding[3:4]
```

Here shows all consequences of coding variants.

```{r, eval = TRUE}
unique(coding$CONSEQUENCE)
```

The coding result can be filtered by different syntaxes and functions. 
**Why are there variants without genes? And duplicates?**

```{r, eval = TRUE}
head(coding[coding$CONSEQUENCE == "frameshift"], 3)
head(coding[!is.na(coding$GENEID)], 3)
```

Those methods can be used to identify variants on specific genes, for example BRAF (Gene ID: 673).

<details>
<summary>Solution</summary>
<ul>
<li>You can't filter on column with NA values.</li>
```{r, eval = TRUE, error = TRUE}
coding[coding$GENEID == "673"]
```
<li>Instead, you should filter out the NA values first.</li>
```{r, eval = TRUE}
gene_coding <- coding[!is.na(coding$GENEID)]
gene_coding[gene_coding$GENEID == "673"]
```
<li>You can further investigate this variant on external databases like [COSMIC](https://cancer.sanger.ac.uk/cosmic/mutation/overview?id=170110762).</li>

</ul>
</details>

#### *Match variants within COSMIC*

**This part is not working as intended, and help needed!**

Read and pre-process COSMIC database.

```{r, eval = TRUE}
cosmic_path <- system.file("vcf", "cosmic_67.vcf.gz", package = "COSMIC.67")
cosmic_db <- readVcf(cosmic_path, genome = "GRCh37")
seqlevels(cosmic_db) <- paste0("chr", seqlevels(cosmic_db))
cosmic_db = renameSeqlevels(cosmic_db, c(chrMT="chrM"))
```

The `match()` function only matches chromosome and ranges but not *ALT*.

```{r, eval = TRUE}
variant_loc <- rowRanges(vcf)
cosmic_loc <- rowRanges(cosmic_db)
overlap <- match(cosmic_loc, variant_loc)
cosmic_overlap <- cosmic_loc[!is.na(overlap)]
```

The bug can be identified from the BRAF V600E example.

```{r, eval = TRUE}
variant_loc[ranges(variant_loc) == "140453136"]
cosmic_overlap[start(ranges(cosmic_overlap)) == "140453136"]
```

biomaRt::select(org.Hs.eg.db, keys=genes(txdb)$gene_id, columns=c("SYMBOL"), keytype="ENTREZID")$SYMBOL
